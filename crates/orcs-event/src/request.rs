//! Request/Response types for Component communication.
//!
//! This module defines the [`Request`] type used for synchronous
//! queries between Components via the EventBus.
//!
//! # Request/Response Pattern
//!
//! ```text
//! ┌─────────────┐  Request   ┌─────────────┐
//! │   Source    │ ─────────► │   Target    │
//! │  Component  │            │  Component  │
//! │             │ ◄───────── │             │
//! └─────────────┘  Response  └─────────────┘
//! ```
//!
//! # Construction
//!
//! Always use [`Request::new`] to create requests. This ensures:
//!
//! - Unique [`RequestId`] is generated
//! - Default timeout is applied
//! - All required fields are provided
//!
//! ```
//! use orcs_event::{Request, EventCategory};
//! use orcs_types::{ComponentId, ChannelId};
//! use serde_json::Value;
//!
//! let source = ComponentId::builtin("llm");
//! let channel = ChannelId::new();
//!
//! let request = Request::new(EventCategory::Echo, "chat", source, channel, Value::Null)
//!     .with_timeout(5000);
//! ```

use crate::{EventCategory, EventError};
use orcs_types::{ChannelId, ComponentId, RequestId, TryNew};
use serde::{Deserialize, Serialize};
use serde_json::Value;

/// Default request timeout in milliseconds (30 seconds).
///
/// This value is applied automatically by [`Request::new`].
/// Use [`Request::with_timeout`] to override.
///
/// # Value
///
/// 30,000 ms = 30 seconds
pub const DEFAULT_TIMEOUT_MS: u64 = 30_000;

/// A synchronous request message between Components.
///
/// Represents a query that expects exactly one `Response`.
///
/// # Required Fields
///
/// All fields except `target` are mandatory and have no sensible defaults:
///
/// | Field | Why No Default |
/// |-------|----------------|
/// | `id` | Must be unique per request (generated by [`Request::new`]) |
/// | `operation` | Defines what action to perform |
/// | `source` | Identifies the requesting Component |
/// | `channel` | Execution context for permission/scope |
/// | `payload` | Operation-specific data |
/// | `timeout_ms` | Has default, but requires explicit construction |
///
/// # Why No `Default` Implementation
///
/// **DO NOT implement `Default` for this type.**
///
/// Reasons:
///
/// 1. **`id` must be unique**: Each request needs a fresh [`RequestId`].
///    A `Default` impl would either reuse the same ID (broken) or
///    generate new ones (hidden side effect in `Default`).
///
/// 2. **`source` is mandatory**: There is no "anonymous" request.
///    Every request must have an identifiable source for routing
///    and permission checking.
///
/// 3. **`channel` is mandatory**: Requests without a channel cannot
///    be scoped for permission inheritance or signal targeting.
///
/// 4. **`operation` is mandatory**: An empty operation string is
///    meaningless and would fail at runtime.
///
/// # Serde Deserialization
///
/// When deserializing, all fields must be present in the input.
/// There are no `#[serde(default)]` attributes intentionally.
/// Partial requests are rejected at deserialization time.
///
/// # Example
///
/// ```
/// use orcs_event::{Request, EventCategory};
/// use orcs_types::{ComponentId, ChannelId};
/// use serde_json::json;
///
/// let request = Request::new(
///     EventCategory::Echo,
///     "read",
///     ComponentId::builtin("tool"),
///     ChannelId::new(),
///     json!({ "path": "/tmp/file.txt" }),
/// );
///
/// assert_eq!(request.operation, "read");
/// assert!(request.target.is_none());
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Request {
    /// Unique identifier for this request.
    ///
    /// Generated automatically by [`Request::new`].
    /// Used to correlate with the corresponding `Response`.
    pub id: RequestId,

    /// Event category for subscription-based routing.
    ///
    /// The EventBus routes this request only to Components
    /// that subscribe to this category.
    pub category: EventCategory,

    /// Operation name (e.g., "chat", "read", "approve").
    ///
    /// Determines how the target Component processes the request.
    pub operation: String,

    /// Source Component that initiated this request.
    ///
    /// Used for:
    /// - Response routing
    /// - Permission checking
    /// - Audit logging
    pub source: ComponentId,

    /// Target Component (optional).
    ///
    /// - `Some(id)`: Direct request to specific Component
    /// - `None`: Broadcast to all Components handling this operation
    pub target: Option<ComponentId>,

    /// Execution context channel.
    ///
    /// Used for:
    /// - Permission scope inheritance
    /// - Signal targeting (cancel, pause, etc.)
    /// - Parallel execution isolation
    pub channel: ChannelId,

    /// Operation-specific payload.
    ///
    /// Structure depends on the `operation` type.
    pub payload: Value,

    /// Timeout in milliseconds.
    ///
    /// Default: [`DEFAULT_TIMEOUT_MS`] (30 seconds).
    /// Override with [`Request::with_timeout`].
    pub timeout_ms: u64,
}

/// Arguments for constructing a [`Request`] via [`TryNew`].
///
/// This struct provides validated request construction.
///
/// # Example
///
/// ```
/// use orcs_event::{Request, RequestArgs, EventCategory};
/// use orcs_types::{ComponentId, ChannelId, TryNew};
/// use serde_json::json;
///
/// let args = RequestArgs {
///     category: EventCategory::Echo,
///     operation: "echo".to_string(),
///     source: ComponentId::builtin("test"),
///     channel: ChannelId::new(),
///     payload: json!({ "message": "Hello" }),
/// };
///
/// let request = Request::try_new(args).expect("valid request");
/// ```
pub struct RequestArgs {
    /// Event category for routing.
    pub category: EventCategory,
    /// Operation name (must not be empty).
    pub operation: String,
    /// Source Component.
    pub source: ComponentId,
    /// Execution context channel.
    pub channel: ChannelId,
    /// Operation-specific payload.
    pub payload: Value,
}

impl TryNew for Request {
    type Error = EventError;
    type Args = RequestArgs;

    /// Attempts to create a new [`Request`] with validation.
    ///
    /// # Validation
    ///
    /// - `operation` must not be empty
    /// - `operation` must not be whitespace-only
    ///
    /// # Errors
    ///
    /// Returns [`EventError::InvalidRequest`] if validation fails.
    ///
    /// # Example
    ///
    /// ```
    /// use orcs_event::{Request, RequestArgs, EventError, EventCategory};
    /// use orcs_types::{ComponentId, ChannelId, TryNew, ErrorCode};
    /// use serde_json::Value;
    ///
    /// // Valid request
    /// let args = RequestArgs {
    ///     category: EventCategory::Echo,
    ///     operation: "echo".to_string(),
    ///     source: ComponentId::builtin("echo"),
    ///     channel: ChannelId::new(),
    ///     payload: Value::Null,
    /// };
    /// assert!(Request::try_new(args).is_ok());
    ///
    /// // Invalid: empty operation
    /// let args = RequestArgs {
    ///     category: EventCategory::Echo,
    ///     operation: String::new(),
    ///     source: ComponentId::builtin("echo"),
    ///     channel: ChannelId::new(),
    ///     payload: Value::Null,
    /// };
    /// let err = Request::try_new(args).unwrap_err();
    /// assert_eq!(err.code(), "EVENT_INVALID_REQUEST");
    /// ```
    fn try_new(args: Self::Args) -> Result<Self, Self::Error> {
        let operation = args.operation.trim();
        if operation.is_empty() {
            return Err(EventError::InvalidRequest(
                "operation cannot be empty".to_string(),
            ));
        }

        Ok(Self {
            id: RequestId::new(),
            category: args.category,
            operation: operation.to_string(),
            source: args.source,
            target: None,
            channel: args.channel,
            payload: args.payload,
            timeout_ms: DEFAULT_TIMEOUT_MS,
        })
    }
}

impl Request {
    /// Creates a new [`Request`] with a unique ID and default timeout.
    ///
    /// **Note**: This method does not validate the operation string.
    /// For validated construction, use [`Request::try_new`] via the
    /// [`TryNew`] trait.
    ///
    /// # Arguments
    ///
    /// * `category` - Event category for routing
    /// * `operation` - Operation name (e.g., "chat", "read")
    /// * `source` - The Component initiating this request
    /// * `channel` - Execution context for scoping
    /// * `payload` - Operation-specific data
    ///
    /// # Example
    ///
    /// ```
    /// use orcs_event::{Request, EventCategory};
    /// use orcs_types::{ComponentId, ChannelId};
    /// use serde_json::json;
    ///
    /// let req = Request::new(
    ///     EventCategory::Echo,
    ///     "echo",
    ///     ComponentId::builtin("test"),
    ///     ChannelId::new(),
    ///     json!({ "message": "Hello" }),
    /// );
    /// ```
    #[must_use]
    pub fn new(
        category: EventCategory,
        operation: impl Into<String>,
        source: ComponentId,
        channel: ChannelId,
        payload: Value,
    ) -> Self {
        Self {
            id: RequestId::new(),
            category,
            operation: operation.into(),
            source,
            target: None,
            channel,
            payload,
            timeout_ms: DEFAULT_TIMEOUT_MS,
        }
    }

    /// Sets the target Component for direct routing.
    ///
    /// By default, requests are broadcast to all Components that
    /// handle the operation. Use this to send directly to one.
    ///
    /// # Example
    ///
    /// ```
    /// use orcs_event::{Request, EventCategory};
    /// use orcs_types::{ComponentId, ChannelId};
    /// use serde_json::Value;
    ///
    /// let req = Request::new(
    ///     EventCategory::Hil,
    ///     "approve",
    ///     ComponentId::builtin("tool"),
    ///     ChannelId::new(),
    ///     Value::Null,
    /// )
    /// .with_target(ComponentId::builtin("hil"));
    ///
    /// assert!(req.target.is_some());
    /// ```
    #[must_use]
    pub fn with_target(mut self, target: ComponentId) -> Self {
        self.target = Some(target);
        self
    }

    /// Sets a custom timeout in milliseconds.
    ///
    /// Default is [`DEFAULT_TIMEOUT_MS`] (30 seconds).
    ///
    /// # Example
    ///
    /// ```
    /// use orcs_event::{Request, EventCategory};
    /// use orcs_types::{ComponentId, ChannelId};
    /// use serde_json::Value;
    ///
    /// // Short timeout for quick operations
    /// let req = Request::new(
    ///     EventCategory::Lifecycle,
    ///     "ping",
    ///     ComponentId::builtin("monitor"),
    ///     ChannelId::new(),
    ///     Value::Null,
    /// )
    /// .with_timeout(1000);  // 1 second
    ///
    /// assert_eq!(req.timeout_ms, 1000);
    /// ```
    #[must_use]
    pub fn with_timeout(mut self, timeout_ms: u64) -> Self {
        self.timeout_ms = timeout_ms;
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn request_creation() {
        let source = ComponentId::builtin("test");
        let channel = ChannelId::new();
        let req = Request::new(
            EventCategory::Echo,
            "echo",
            source.clone(),
            channel,
            Value::String("hello".into()),
        );

        assert_eq!(req.category, EventCategory::Echo);
        assert_eq!(req.operation, "echo");
        assert_eq!(req.source, source);
        assert!(req.target.is_none());
        assert_eq!(req.timeout_ms, DEFAULT_TIMEOUT_MS);
    }

    #[test]
    fn request_with_target() {
        let source = ComponentId::builtin("source");
        let target = ComponentId::builtin("target");
        let channel = ChannelId::new();
        let req = Request::new(EventCategory::Hil, "submit", source, channel, Value::Null)
            .with_target(target.clone());

        assert_eq!(req.target, Some(target));
    }

    #[test]
    fn request_unique_ids() {
        let source = ComponentId::builtin("test");
        let channel = ChannelId::new();
        let req1 = Request::new(
            EventCategory::Echo,
            "op1",
            source.clone(),
            channel,
            Value::Null,
        );
        let req2 = Request::new(EventCategory::Echo, "op2", source, channel, Value::Null);

        assert_ne!(req1.id, req2.id);
    }

    #[test]
    fn request_with_custom_timeout() {
        let source = ComponentId::builtin("test");
        let channel = ChannelId::new();
        let req = Request::new(EventCategory::Echo, "op", source, channel, Value::Null)
            .with_timeout(5000);

        assert_eq!(req.timeout_ms, 5000);
    }

    #[test]
    fn try_new_valid_request() {
        let args = RequestArgs {
            category: EventCategory::Echo,
            operation: "echo".to_string(),
            source: ComponentId::builtin("echo"),
            channel: ChannelId::new(),
            payload: Value::Null,
        };

        let result = Request::try_new(args);
        assert!(result.is_ok());

        let req = result.expect("try_new with valid 'echo' operation should succeed");
        assert_eq!(req.category, EventCategory::Echo);
        assert_eq!(req.operation, "echo");
    }

    #[test]
    fn try_new_empty_operation_fails() {
        use orcs_types::ErrorCode;

        let args = RequestArgs {
            category: EventCategory::Echo,
            operation: String::new(),
            source: ComponentId::builtin("echo"),
            channel: ChannelId::new(),
            payload: Value::Null,
        };

        let result = Request::try_new(args);
        assert!(result.is_err());

        let err = result.expect_err("try_new with empty operation should return error");
        assert_eq!(err.code(), "EVENT_INVALID_REQUEST");
    }

    #[test]
    fn try_new_whitespace_only_operation_fails() {
        use orcs_types::ErrorCode;

        let args = RequestArgs {
            category: EventCategory::Echo,
            operation: "   ".to_string(),
            source: ComponentId::builtin("echo"),
            channel: ChannelId::new(),
            payload: Value::Null,
        };

        let result = Request::try_new(args);
        assert!(result.is_err());

        let err = result.expect_err("try_new with whitespace-only operation should return error");
        assert_eq!(err.code(), "EVENT_INVALID_REQUEST");
    }

    #[test]
    fn try_new_trims_operation() {
        let args = RequestArgs {
            category: EventCategory::Echo,
            operation: "  echo  ".to_string(),
            source: ComponentId::builtin("echo"),
            channel: ChannelId::new(),
            payload: Value::Null,
        };

        let result = Request::try_new(args);
        assert!(result.is_ok());

        let req = result.expect(
            "try_new with whitespace-padded 'echo' operation should succeed after trimming",
        );
        assert_eq!(req.operation, "echo");
    }

    #[test]
    fn request_category_routing() {
        let source = ComponentId::builtin("test");
        let channel = ChannelId::new();

        let hil_req = Request::new(
            EventCategory::Hil,
            "submit",
            source.clone(),
            channel,
            Value::Null,
        );
        let echo_req = Request::new(EventCategory::Echo, "echo", source, channel, Value::Null);

        assert!(hil_req.category.is_hil());
        assert!(!echo_req.category.is_hil());
    }
}
