//! Builtin components shipped with the binary.
//!
//! Components are embedded at compile time via `build.rs` auto-generation.
//! At runtime, [`ensure_expanded`] writes them to a versioned directory
//! under the configured builtins path (default `~/.orcs/builtins/vX.Y.Z/components/`).
//!
//! Users never need to touch this directory â€” it is fully managed by ORCS.
//! User components and customizations live in separate paths (e.g. `~/.orcs/components/`).

use std::path::{Path, PathBuf};

// Auto-generated by build.rs: array of (relative_path, source_content).
include!(concat!(env!("OUT_DIR"), "/builtins_gen.rs"));

/// Returns the versioned builtins directory: `{base}/v{CARGO_PKG_VERSION}/components`.
#[must_use]
pub fn versioned_dir(base: &Path) -> PathBuf {
    base.join(format!("v{}", env!("CARGO_PKG_VERSION")))
        .join("components")
}

/// Ensures all builtin components are expanded to disk at the versioned directory.
///
/// - If the versioned directory already exists, returns `Ok(vec![])` immediately.
/// - Otherwise creates the full directory tree and writes all files.
/// - Directory structure is preserved (e.g. `skill_manager/init.lua`).
///
/// # Errors
///
/// Returns `std::io::Error` if directory creation or file writes fail.
pub fn ensure_expanded(base_dir: &Path) -> Result<Vec<PathBuf>, std::io::Error> {
    let target = versioned_dir(base_dir);

    if target.exists() {
        return Ok(vec![]);
    }

    let mut written = Vec::new();

    for (rel_path, content) in FILES {
        let dest = target.join(rel_path);
        if let Some(parent) = dest.parent() {
            std::fs::create_dir_all(parent)?;
        }
        std::fs::write(&dest, content)?;
        written.push(dest);
    }

    Ok(written)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn files_is_not_empty() {
        assert!(
            !FILES.is_empty(),
            "build.rs should have generated at least one entry"
        );
    }

    #[test]
    fn files_contains_echo() {
        let has_echo = FILES.iter().any(|(path, _)| *path == "echo.lua");
        assert!(has_echo, "builtins should include echo.lua");
    }

    #[test]
    fn files_contains_skill_manager_init() {
        let has = FILES
            .iter()
            .any(|(path, _)| *path == "skill_manager/init.lua");
        assert!(has, "builtins should include skill_manager/init.lua");
    }

    #[test]
    fn versioned_dir_includes_version() {
        let dir = versioned_dir(Path::new("/base"));
        let dir_str = dir.to_string_lossy();
        assert!(
            dir_str.contains(env!("CARGO_PKG_VERSION")),
            "should contain crate version: {dir_str}"
        );
        assert!(
            dir_str.ends_with("components"),
            "should end with components: {dir_str}"
        );
    }

    #[test]
    fn ensure_expanded_creates_files() {
        let tmp = tempfile::tempdir().expect("create temp dir");
        let written = ensure_expanded(tmp.path()).expect("expansion should succeed");

        assert_eq!(written.len(), FILES.len(), "should write all files");

        // Verify directory component exists
        let sm_init = versioned_dir(tmp.path()).join("skill_manager/init.lua");
        assert!(sm_init.exists(), "skill_manager/init.lua should exist");
    }

    #[test]
    fn ensure_expanded_skips_existing_version() {
        let tmp = tempfile::tempdir().expect("create temp dir");
        ensure_expanded(tmp.path()).expect("first expansion");

        let second = ensure_expanded(tmp.path()).expect("second expansion");
        assert!(second.is_empty(), "should skip existing version");
    }
}
